<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0" />
<title>Bouncing Ball in Rotating Hexagon</title>
<style>
  body {
    margin: 0;
    background: #111;
    display: flex;
    justify-content: center;
    align-items: center;
    height: 100vh;
    overflow: hidden;
    color: white;
    font-family: sans-serif;
  }
  canvas {
    background: #222;
    border: 2px solid #fff;
    display: block;
  }
</style>
</head>
<body>
<canvas id="sim" width="600" height="600"></canvas>
<script>
const canvas = document.getElementById("sim");
const ctx = canvas.getContext("2d");

const center = { x: canvas.width / 2, y: canvas.height / 2 };
let hexRadius = 200;
let rotationSpeed = 0.01; // radians per frame
let angleOffset = 0;

// Ball properties
let ball = {
  x: center.x,
  y: center.y - 50,
  radius: 10,
  vx: 3,
  vy: 2
};

// Physics
const restitution = 0.9; // bounce damping

function getHexVertices(radius, angleOffset) {
  let vertices = [];
  for (let i = 0; i < 6; i++) {
    let angle = angleOffset + i * (Math.PI / 3);
    vertices.push({
      x: center.x + radius * Math.cos(angle),
      y: center.y + radius * Math.sin(angle)
    });
  }
  return vertices;
}

function drawHex(vertices) {
  ctx.beginPath();
  ctx.moveTo(vertices[0].x, vertices[0].y);
  for (let i = 1; i < vertices.length; i++) {
    ctx.lineTo(vertices[i].x, vertices[i].y);
  }
  ctx.closePath();
  ctx.strokeStyle = "white";
  ctx.lineWidth = 2;
  ctx.stroke();
}

function drawBall() {
  ctx.beginPath();
  ctx.arc(ball.x, ball.y, ball.radius, 0, Math.PI * 2);
  ctx.fillStyle = "cyan";
  ctx.fill();
}

function updateBall(vertices) {
  ball.x += ball.vx;
  ball.y += ball.vy;

  // Collision with each hexagon side
  for (let i = 0; i < vertices.length; i++) {
    let p1 = vertices[i];
    let p2 = vertices[(i + 1) % vertices.length];

    // Line equation
    let dx = p2.x - p1.x;
    let dy = p2.y - p1.y;
    let length = Math.sqrt(dx * dx + dy * dy);
    let nx = dy / length; // normal x
    let ny = -dx / length; // normal y

    // Distance from ball to line
    let dist = (ball.x - p1.x) * nx + (ball.y - p1.y) * ny;

    if (dist < ball.radius) {
      // Reflect velocity
      let dot = ball.vx * nx + ball.vy * ny;
      ball.vx -= 2 * dot * nx;
      ball.vy -= 2 * dot * ny;

      ball.vx *= restitution;
      ball.vy *= restitution;

      // Push ball out of wall
      let overlap = ball.radius - dist;
      ball.x += nx * overlap;
      ball.y += ny * overlap;
    }
  }
}

function loop() {
  ctx.clearRect(0, 0, canvas.width, canvas.height);

  angleOffset += rotationSpeed;
  const vertices = getHexVertices(hexRadius, angleOffset);

  drawHex(vertices);
  updateBall(vertices);
  drawBall();

  requestAnimationFrame(loop);
}

loop();
</script>
</body>
</html>
